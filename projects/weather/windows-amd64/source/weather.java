/* autogenerated by Processing revision 1283 on 2022-06-05 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class weather extends PApplet {

/**
MOVE THE MOUSE TO CONTORL THE WEATHER

UP-DOWN IS HUMIDITY
LEFT-RIGHT IS WIND
MOUSE WHEEL FOR TEMPERATURE
 */

// adjustable settings isn't in the rubric and many of these break stuff if changed, so just change the number of stars lol
// settings:
int starCount = 1000;

// don't adjust:
float delay = 6;
int dayNightFade = 10; // breaks if this becomes too large, depends on dayLength
int dayLength = 128; // strictly less than 255

// global weather variables
float humidity; // between 0 and 1
float temp; // between -10 and 40
float wind; // between -1 and 1

// day length based on dayLength, night from 0-day and night-255, smooth transition over like dayNightFade
float time;
float day;
float night;

PVector skyPivot;

// weather objects
Sun sun;
ArrayList<Cloud> clouds;

ArrayList<Firefly> fireflies;

// keeps the sky different each run, but the same every night
int randomS = millis();

// smooths out the sky clouding effect over several cycles
int cloudSmoothness = 180; // how many frames to smooth over
float[] cloudBuffer;

 public void setup() {
    /* size commented out by preprocessor */;

    time = 0;
    day = 128-dayLength/2;
    night = 128+dayLength/2;

    humidity = 0;
    temp = 10;
    wind = 0;

    skyPivot = new PVector(width*2, height*3/4);

    sun = new Sun(20);
    clouds = new ArrayList<Cloud>();
    
    fireflies = new ArrayList<Firefly>(); 

    cloudBuffer = new float[cloudSmoothness];
}

// quick disclaimer that the numbers and formulas are somewhat janky due to lots of tweaking. 
 public void draw() {
    time = (time+0.2f) % 256;

    mouseAffect();
    drawSky();

    sun.update();

    greySky();

    // fireflies spawn all the time but leave if they're not happy (a.k.a. i can't be bothered to code spawn logic)
    if (random(1) < 0.01f) {
        fireflies.add(new Firefly(random(1)*width, random(0.8f, 1)*height));
    }

    for (int i = fireflies.size() - 1; i >= 0; i--) {
        fireflies.get(i).update();
    }

    // affected temperature for this draw cycle only
    float tempTemp = temp + sun.warmth();

    // oof giant if block incoming

    // make fog when at max humidity and very little wind or cloud cover, also only during the morning lol
    if (0 < tempTemp && tempTemp < 20 && abs(wind) < 0.25f && cloudCover() < 4 && abs(time-day) <= dayNightFade*2) {
        // most likely at mouse 1/3 of the way down, and even so only 40% chance to be created
        if (random(0.3f) > abs(PApplet.parseFloat(mouseY)/height - 0.3f) && random(1) < 0.4f) {
            float h = random(5, 10);

            // any x position (including slightly off the screen), and height in the bottom half
            clouds.add(new Cloud(random(-0.25f, 1.25f)*width, random(0.5f, 1)*height, h, "fog"));

            // drop humidity very little so it recovers faster and makes fog again sooner
            humidity = max(0, humidity - h/40);
        }
        
    // make thundercloud
    } else if (13 < tempTemp && tempTemp < 33 && abs(wind) == 1 && humidity >= maxHumidity()-0.15f) {
        // i don't even know lol
        if (random(0.005f*pow(tempTemp - 24, 2)+0.3f) < humidity/2 + 0.25f) {
            float h = random(humidity*4, humidity*20);

            // any x position and only in a narrow band near the top
            clouds.add(new Cloud(random(-0.25f, 1.25f)*width, random(0.1f, 0.25f)*height, h, "thunder"));
        
            // don't drop the humidity as much to promote frequent cloud formation
            humidity = max(0, humidity - h/30.0f);
        }

    // rain cloud, requires some wind to form and mouse must not be at the top (not enough humidity)
    } else if (height/4 < mouseY && wind != 0 && humidity/maxHumidity() > 0.2f) {
        // probability of creation varies proportional to how high the mouse is
        if (random(1) < (PApplet.parseFloat(mouseY)/height)/1.5f - 0.2f) {
            // also proportional to how far from the center, wind can't be 0, but near 0 should have few clouds
            if (random(1) < abs(wind)*2) {
                float h = random(2, 10);

                // any x position and anywhere in the top 1/3 of the screen
                clouds.add(new Cloud(random(-0.25f, 1.25f)*width, random(0.33f)*height, h, "rain"));
                
                // subtract this cloud's size from the current humidity, don't let it go negative
                humidity = max(0, humidity - h/20.0f);
            }
        }
    }

    // update the rain first
    for (Cloud cloud : clouds) {
        cloud.updateRain();
    }

    // then update all the clouds
    for (int i = clouds.size() - 1; i >= 0; i--) {
        clouds.get(i).update();
    }

    thermometer();
}

// draws the sky with stars
 public void drawSky() {
    // black sky
    background(0);

    // draw the stars
    pushMatrix();
    translate(skyPivot.x, skyPivot.y);
    rotate(time*TWO_PI/256);

    fill(255);
    noStroke();
    randomSeed(randomS);

    // fill stars into a giant square with side lenght equal to twice the distance from the pivot to (0, 0)
    int sideLength = PApplet.parseInt(dist(skyPivot.x, skyPivot.y, 0, 0));

    for (int i = 0; i < starCount; i++) {
        circle(random(-sideLength, sideLength), random(-sideLength, sideLength), sqrt(random(16)));
    }
    
    popMatrix();
    
    // fill transparent (almost transparent, for some reason alpha = 0 isn't working)
    int sky = color(0, 0, 0, 1);

    // could do some really fancy function but this is easier to understand
    // smooths the color fade from day to night
    if (day - dayNightFade < time && time < day + dayNightFade) sky = color(3, 169, 244, map(time, day-dayNightFade, day+dayNightFade, 0, 255));
    if (night - dayNightFade < time && time < night + dayNightFade) sky = color(3, 169, 244, map(time, night-dayNightFade, night+dayNightFade, 255, 0));
    
    // if it's not fading just fill with sky
    if (day + dayNightFade <= time && time <= night - dayNightFade) sky = color(3, 169, 244);

    fill(sky);
    rectMode(CORNER);
    rect(0, 0, width, height);

    // reset the random seed for use elsewhere
    randomSeed(millis()*10);
}

// greys over the sun and sky with a grey, but still below the clouds and rain
 public void greySky() {
    float average = 0;
    for (int i = cloudSmoothness - 2; i > 0; i--) {
        average += cloudBuffer[i];
        cloudBuffer[i] = cloudBuffer[i+1]; 
    }

    float currentCover = cloudCover();

    average += currentCover;
    cloudBuffer[cloudSmoothness - 1] = currentCover;
    average /= cloudSmoothness;

    fill(lerpColor(color(0, 0, 0, 0), color(80, 80, 80, 180), sqrt(average/10)));

    rectMode(CORNER);
    rect(0, 0, width, height);
}

 public void mouseAffect() {
    // HUMIDITY --------------------
    float targetHumidity;

    // top quarter has no humidity
    if (mouseY < height/4) targetHumidity = 0;

    // bottom quarter has max humidity
    else if (mouseY > 3*height/4) targetHumidity = maxHumidity();

    // even map between them
    else targetHumidity = map(mouseY, height/4, 3*height/4, 0, maxHumidity());

    humidity += (targetHumidity - humidity)/delay;

    if (abs(humidity-targetHumidity) < 0.005f) humidity = targetHumidity;

    // WIND ------------------------
    float targetWind;
    
    // how far is it from the center from 0 to 1
    float n = abs(mouseX - width/2)/PApplet.parseFloat(width/2);

    if (n < 0.15f) targetWind = 0;
    else if (n < 0.8f) targetWind = map(n, 0.15f, 0.8f, 0, 1);
    else targetWind = 1;

    // affected by the direction of the mouse from the center
    if (targetWind != 0) targetWind *= (mouseX - width/2)/abs(mouseX - width/2);

    wind += (targetWind - wind)/delay;
    if (abs(wind-targetWind) < 0.005f) wind = targetWind;
}

 public void mouseWheel(MouseEvent event) {
    float e = event.getCount();
    
    if (-10 <= temp - e && temp - e <= 40) {
        temp -= e;
        // println(temp);
    }
}

// maximum humidity given temperature
 public float maxHumidity() {
    // maps temperature to humidity, with max always positive
    // i'm aware 
    return map(temp + sun.warmth(), -20, 50, 0.1f, 1);
}

// value from 0 to 10 related to the current cloud cover
 public float cloudCover() {
    // total amount of cloudcover present
    float cloudVolume = 0;
    for (Cloud cloud : clouds) {
        cloudVolume += cloud.size;

        // thunderstorms are worth double
        if (cloud.type == "thunder") cloudVolume += cloud.size;
    }

    return 10.0f/(1+pow(2.71828f, -1*((cloudVolume/20.0f)-5)));
}

// draws a thermometer on the screen from middle left to bottom left
 public void thermometer() {
    // body outline
    strokeWeight(15);
    stroke(0);
    line(15, height/2, 15, height-15);

    // body
    strokeWeight(14);
    stroke(150);
    line(15, height/2, 15, height-15);

    // bulb outline
    noStroke();
    fill(0);
    circle(15, height-15, 25);

    // bulb
    fill(255, 0, 0);
    circle(15, height-15, 24);

    // thermometer liquid
    strokeWeight(14);
    stroke(255, 0, 0);
    line(15, height-15, 15, map(temp+sun.warmth(), -20, 50, height-15, height/2));

    // 0 C indicator
    strokeWeight(3);
    stroke(0, 0, 255);
    int y = height/2 + (height-15 - height/2)*5/7; // yes i could've coded this more nicely but it's 9:30 and i've been at this like 5 hours and i'm so tired lol
    line(8, y, 22, y);
}
// in the same file cause thunder is small and uses bolt extensively
class Bolt {
    static final int length = 25;
    static final int maxAge = 10;

    float posX;
    float posY;
    PVector dir; // contant length
    Bolt parent;
    ArrayList<Bolt> children;
    int age;

    // head bolt, no parent
    Bolt(float x, float y) {
        this.posX = x;
        this.posY = y;
        this.dir = new PVector(0, length);

        this.parent = null;
        this.children = new ArrayList<Bolt>();

        this.age = 0;
    }

    Bolt(float x, float y, PVector dir, Bolt parent) {
        this(x, y);
        this.parent = parent;

        // overwrites the dir set in the normal constructor
        this.dir = dir;
    }

     public int update() {
        // don't update or wait on bolts below the bottom of the screen
        if (posY >= height) return maxAge;

        age++;

        // keep track of the minimum age of the children, and if they're all diappeared delete the tree
        int minAge = age;
        
        // if this branch was just made don't update the children
        if (age == 1) split();

        // if it's older, update the children and keep track of their minimum ages
        else {
            for (Bolt child : children) minAge = min(minAge, child.update());
        }

        // don't draw it if it's already died
        if (age <= maxAge) {
            stroke(255, 255, 0, 255*(maxAge - age)/maxAge); // alpha value that smoothly goes to 0 as the age reaches maxAge
            strokeWeight(2);
            line(posX, posY, posX + dir.x, posY + dir.y);
        }

        return minAge;
    }

     public void split() {
        float x = posX + dir.x;
        float y = posY + dir.y;

        // random number to decide how many branches to make
        int n;
        float r = random(1);

        // very high likelyhood for 1, small chance of 2 and even smaller of 3 (freak occurence). it also has a chance to end the branch spontaneously 
        if (r < 0.005f) n = 3;
        else if (r < 0.07f) n = 2;
        else if (r < 0.97f) n = 1;
        else n = 0;

        for (int i = 0; i < n; i++) {
            PVector newDir = new PVector(0, length);
            newDir.rotate(random(-1*PI/4, PI/4));

            children.add(new Bolt(x, y, newDir, this));
        }
    }
}
class Cloud {
    static final int sizeMod = 20;
    static final float ageMod = 0.8f;

    float posX;
    float posY;
    float size;
    String type;
    ArrayList<Rain> rain;
    ArrayList<Bolt> lightningBolts;
    
    int age;
    boolean empty;

    Cloud(float posX, float posY, float size, String type) {
        this.posX = posX;
        this.posY = posY;
        this.size = size;
        this.type = type;

        this.age = 0;
        this.empty = false;

        rain = new ArrayList<Rain>();
        lightningBolts = new ArrayList<Bolt>();
    }

     public void update() {
        // i can't just delete the clouds when they run out cause they handle the rain, so keep them around until all the rain is gone
        if (empty && rain.size() > 0) return;
        else if (empty) {
            clouds.remove(this);
            return;
        } else if (size <= 0) empty = true;

        age++;
        rectMode(CENTER);
        posX += wind*5;

        // delete if it gets too far out of bounds
        if (posX < -1*width/2.0f || width*1.5f < posX) clouds.remove(this);

        if (type == "rain") {
            noStroke();

            // if it's young just make it get bigger
            if (age*ageMod <= size) {
                float s = age*ageMod*sizeMod;

                // two layer drawing, with more opacity in the middle
                fill(100, 75);
                rect(posX, posY, s/1.5f, s/1.5f, s/12);

                fill(150, 40);
                rect(posX, posY, s, s, s/8);
            
            // otherwise draw and rain and change size
            } else {
                // two layer drawing, with more opacity in the middle
                fill(100, 75);
                rect(posX, posY, size*sizeMod/1.5f, size*sizeMod/1.5f, size*sizeMod/12);

                fill(150, 40);
                rect(posX, posY, size*sizeMod, size*sizeMod, size*sizeMod/8);

                if (height/2 < mouseY && random(1) < PApplet.parseFloat(mouseY)/height - 0.5f) { 
                    rain.add(new Rain(random(posX - size*sizeMod/2, posX + size*sizeMod/2), random(posY - size*sizeMod/2, posY + size*sizeMod/2), this));
                    size -= 0.1f;

                
                // even if it can't rain still reduce the size slightly
                } else {
                    size -= 0.05f;
                }
            }
        }
        if (type == "thunder") {
            // again, if it's young just grow it
            if (age*ageMod < size) {
                float s = age*ageMod*sizeMod;

                noStroke();

                fill(75, 100);
                rect(posX, posY, s/1.5f, s/0.75f, s/12);

                fill(100, 60);
                rect(posX, posY, s, s*2, s/8);
            } else {
                // update lightning first, so that it's underneath the cloud (note that this does make it over the previous clouds, but that's fine and makes some logical sense)
                if (lightningBolts.size() > 0) {
                    // iterating backwards so we can delete them as we go
                    for (int i = lightningBolts.size()-1; i > 0; i--) {
                        // if the minimum age of every branch in this bolt is exceeding maxAge, remove the root from the list of bolts
                        // i'm assuming java cleans up all of the children recursively when i do this
                        if (lightningBolts.get(i).update() >= Bolt.maxAge) lightningBolts.remove(i);
                    }
                }

                if (random(1) < 0.01f) lightningBolts.add(new Bolt(
                    random(posX - size*sizeMod/2, posX + size*sizeMod/2),
                    random(posY + size*sizeMod - size, posY + size*sizeMod + size)
                ));

                noStroke();

                fill(75, 100);
                rect(posX, posY, size*sizeMod/1.5f, size*sizeMod/0.75f, size*sizeMod/12);

                fill(100, 60);
                rect(posX, posY, size*sizeMod, size*sizeMod*2, size*sizeMod/8);

                // always rains
                rain.add(new Rain(
                    random(posX - size*sizeMod/2, posX + size*sizeMod/2), 
                    random(posY - size*sizeMod, posY + size*sizeMod), this
                ));

                // holds more rain per size than previous clouds
                size -= 0.025f;
            }
        }

        // fog doesn't rain and only dissapates
        if (type == "fog") {
            // if it's young just make it get bigger
            if (age*ageMod <= size) {
                float s = age*ageMod*sizeMod;

                fill(150, 75);
                rect(posX, posY, s/0.25f, s/1.5f, s/12);

                fill(175, 40);
                rect(posX, posY, s*6, s, s/8);
            
            // otherwise draw and rain and change size
            } else {
                // two layer drawing, with more opacity in the middle
                fill(125, 75);
                rect(posX, posY, size*sizeMod/0.25f, size*sizeMod/1.5f, size*sizeMod/12);

                fill(175, 40);
                rect(posX, posY, size*sizeMod*6, size*sizeMod, size*sizeMod/8);

                size -= 0.01f;
            }

        }
    }

     public void updateRain() {
        for (int i = rain.size() - 1; i >= 0; i--) {
            rain.get(i).update();
        }
    }

     public void removeRain(Rain r) {
        rain.remove(r);
    }
}
class Firefly {
    float posX;
    float posY;
    float light;
    boolean lightUp; // whether light is coming on or going off
    PVector dir;

    Firefly(float x, float y) {
        this.posX = x;
        this.posY = y;

        lightUp = true;
        this.light = 0;

        this.dir = new PVector(0, -2);
    }

     public void update() {
        // if there are clouds forming they run and hide
        boolean areClouds = height/2 < mouseY || clouds.size() > 10;
        
        // otherwise it's clear to move around
        if (!areClouds) {
            // if it's too low
            if (height*11/12 < posY) {
                if (0 <= dir.x) dir.rotate(-0.1f);
                else dir.rotate(0.1f);
            
            // too high
            } else if (posY < height*5/8) {
                if (0 <= dir.x) dir.rotate(0.1f);
                else dir.rotate(-0.1f);
            
            // in the middle
            } else {
                dir.rotate(random(-0.1f, 0.1f));
            }
        }

        // only run and hide if there are clouds
        if (areClouds) {
            posY += 10;
        } else {
            posX += dir.x;
            posY += dir.y;
        }

        // strongly affected by the wind
        posX += wind*3;

        // don't let it travel out of bounds
        if (posX < 0 || width < posX || height < posY) {
            fireflies.remove(this);
        }

        // daytime or if there are clouds it's just a brown fly
        if ((day < time && time < night) || areClouds) {
            fill(0xFF1D120B);
            light = 0;

        // otherwise it must be a clear night
        } else {
            fill(lerpColor(0xFF1D120B, 0xFFFFFF00, light));

            if (lightUp) {
                light += 0.05f;

                if (light >= 1) lightUp = false;
            } else {
                light -= 0.05f;

                if (light <= 0) lightUp = true;
            }
        }

        circle(posX, posY, 3);

        // small chance to reproduce
        if (random(1) < 0.005f) {
            fireflies.add(new Firefly(posX, posY));
        }
    }
}
class Rain {
    float posX;
    float posY;
    boolean snow;
    boolean frozen;

    // always has magnitude 1, shows what direction it's currently travelling in by small air currents
    // this isn't affected by wind and is random
    PVector dir;

    // used to make snow spin
    float snowRotation;

    // parent cloud
    Cloud cloud;

    Rain(float posX, float posY, Cloud cloud) {
        this.posX = posX;
        this.posY = posY;
        this.cloud = cloud;

        dir = new PVector(0, 1);

        // if the temp < 0, make it snow
        if (temp + sun.warmth() < 0) {
            this.snow = true;

            this.frozen = true;
        }
    }

     public void update() {
        noStroke();

        float tempTemp = temp + sun.warmth();

        // freezes in the air (this should probably use tempTemp, but it looks better using temp, because it freezes midair less often)
        if (!frozen && temp < 0 && random(1) > 0.975f) frozen = true;

        // if temp is high, melt the snow or frozen rain
        if (frozen && tempTemp > 0 && random(1) > 0.95f) {
            snow = false;
            frozen = false;
        }

        if (dir.heading() < PI*3/4) dir.rotate(random(-0.05f, 0.1f));
        if (dir.heading() > PI*3/4) dir.rotate(random(-0.1f, 0.05f));

        // Move and draw the rain based on its state
        if (snow) {
            // snow is extra chaotic, greater dir influence
            posY += 3 + dir.y*3;
            posX += wind*10 + dir.x*3;

            stroke(255);
            strokeWeight(2);

            pushMatrix();
            
            translate(posX, posY);
            rotate(snowRotation);

            // draw a small cross
                            point(0, -1);   
            point(-1, 0);   point(0, 0);    point(1, 0);
                            point(0, 1);

            popMatrix();

            // turn it for next time
            snowRotation = (snowRotation + 0.05f) % TWO_PI;

        // freezing rain/hail
        } else if (frozen) {
            // not random and drops quickly, nasty stuff
            posY += 15;
            posX += wind;

            rectMode(CENTER);

            fill(100, 0, 255, 200);
            square(posX, posY, 5);

        // rain
        } else {
            posY += 10 + dir.y;
            posX += wind*2 + dir.x;

            fill(0, 0, 255);

            // draws a droplet
            // copy pasted from my cellular automata
            pushMatrix();

            float w = 5;
  
            translate(posX, posY);
            rotate(-1*wind*PI/4 );

            beginShape();
            curveVertex(0, -w/2);
            curveVertex(0, -w/2);

            curveVertex(-w/2, w/6);
            curveVertex(0, w/2);
            curveVertex(w/2, w/6);
            
            curveVertex(0, -w/2);
            curveVertex(0, -w/2);
            endShape();

            popMatrix();

        }

        if (height < posY) cloud.removeRain(this);
    }
}
class Sun {
    int size;
    int radius;

    PVector pivot;

    Sun() {
        this(30);
    }

    Sun(int size) {
        this.size = size;

        // distance from pivot to the bottom left of the screen
        this.radius = PApplet.parseInt(dist(skyPivot.x, skyPivot.y, width/8, height));
    }

     public void update() {
        noStroke();

        int xPos = PApplet.parseInt(skyPivot.x + radius*cos((time+day-dayNightFade)*2*PI/255));
        int yPos = PApplet.parseInt(skyPivot.y + radius*sin((time+day-dayNightFade)*2*PI/255));

        if (yPos > height) {
            int steps = 2*width/size;
        
            for (int i = 2; i <= steps; i++) {
                fill(255, 80, 0, 255*steps/i*pow(map(yPos, height+width, height, 0.3f, 0), 2));
                circle(xPos, yPos, size*i);
            }
        } else {
            int steps = width/size/2;

            for (int i = 2; i <= steps; i++) {
                fill(255, 230, 0, 255*steps/i*pow(map(max(height/2, yPos), height, height/2, 0, 0.2f), 2));
                circle(xPos, yPos, size*i/2);
            }
        }
        
        fill(0xFFFFEB3B);
        circle(xPos, yPos, size);
    }

     public float warmth() {
        float sunEffect = 10 - cloudCover();

        // if it's night, make it cold 
        if (time <= day - dayNightFade) {
            return -1*sunEffect;

        // fade the temperature in the morning
        } else if (day - dayNightFade < time && time <= day + dayNightFade) {
            return sunEffect * (2/(1+pow(2.71828f, -7*(time-day)/dayNightFade)) - 1);
        
        // full effect during the day
        } else if (day + dayNightFade < time && time <= night - dayNightFade) {
            return sunEffect;
        
        // fade the effect in the evening
        } else if (night - dayNightFade < time && time <= night + dayNightFade) {
            return sunEffect * (-2/(1+pow(2.71828f, -7*(time-night)/dayNightFade)) + 1);
        
        // full negative effect in overnight
        } else {
            return -1*sunEffect;
        }
    }
}


  public void settings() { size(600, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "weather" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
